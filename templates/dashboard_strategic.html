{% extends "base.html" %}

{% block title %}Strategic Dashboard{% endblock %}

{% block head %}
<style>
    .chart-container {
        position: relative;
        height: 400px;
        margin-bottom: 30px;
    }
    .section-header {
        background-color: #f8f9fa;
        border-left: 4px solid #0d6efd;
        padding: 10px 15px;
        margin-bottom: 20px;
    }
    .card-header {
        background-color: #fff;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        font-weight: 600;
        font-size: 1.1rem;
        padding: 1rem 1.25rem;
    }
    .chart-container canvas {
        padding: 10px;
        transition: all 0.3s ease;
    }
    .card-body {
        padding: 1.25rem;
    }
</style>
{% endblock %}

{% block content %}
<h1 class="mb-4">Strategic Dashboard â€” Pricing Trends</h1>

<!-- Filters -->
<div class="card mb-4">
    <div class="card-header">
        <h5 class="mb-0">Filters</h5>
    </div>
    <div class="card-body">
        <form class="row" id="filterForm">
            <div class="col-md-4 mb-3">
                <label for="categoryFilter" class="form-label">Product Category</label>
                <select class="form-select" id="categoryFilter">
                    <option value="all">All Categories</option>
                    {% for category in categories %}
                    <option value="{{ category.CategoryName }}">{{ category.CategoryName }}</option>
                    {% endfor %}
                </select>
            </div>
            <div class="col-md-4 mb-3">
                <label for="dateRangeFilter" class="form-label">Date Range</label>
                <select class="form-select" id="dateRangeFilter">
                    <option value="6">Last 6 months</option>
                    <option value="3">Last 3 months</option>
                    <option value="12">Last 12 months</option>
                </select>
            </div>
            <div class="col-md-4 mb-3 d-flex align-items-end">
                <button type="button" class="btn btn-primary" id="applyFilters">Apply Filters</button>
            </div>
        </form>
    </div>
</div>

<!-- Section 1: Context -->
<div class="section-header">
    <h2>Context</h2>
    <p>This dashboard provides strategic pricing insights to optimize your product pricing strategy. Key metrics include price trends over time, price volatility by category, and comparative pricing across your product portfolio.</p>
</div>

<div class="row">
    <div class="col-md-4 mb-3">
        <div class="card h-100">
            <div class="card-body">
                <h5 class="card-title">Categories</h5>
                <p class="display-4">{{ summary_data|length }}</p>
                <p class="text-muted">Number of product categories</p>
            </div>
        </div>
    </div>
    <div class="col-md-4 mb-3">
        <div class="card h-100">
            <div class="card-body">
                <h5 class="card-title">Price Range</h5>
                <p class="display-4">${{ summary_data[0].MinPrice }} - ${{ summary_data[0].MaxPrice }}</p>
                <p class="text-muted">Min-Max price in selected category</p>
            </div>
        </div>
    </div>
    <div class="col-md-4 mb-3">
        <div class="card h-100">
            <div class="card-body">
                <h5 class="card-title">Average Price</h5>
                <p class="display-4">${{ summary_data[0].AvgPrice }}</p>
                <p class="text-muted">Average product price</p>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-md-4 mb-3">
        <div class="card h-100">
            <div class="card-body">
                <h5 class="card-title">Most Stable Category</h5>
                <p class="display-4" id="most-stable-category">Loading...</p>
                <p class="text-muted">Category with lowest price volatility</p>
            </div>
        </div>
    </div>
    <div class="col-md-4 mb-3">
        <div class="card h-100">
            <div class="card-body">
                <h5 class="card-title">Most Volatile Category</h5>
                <p class="display-4" id="most-volatile-category">Loading...</p>
                <p class="text-muted">Category with highest price volatility</p>
            </div>
        </div>
    </div>
    <div class="col-md-4 mb-3">
        <div class="card h-100">
            <div class="card-body">
                <h5 class="card-title">Total Products</h5>
                <p class="display-4" id="total-products">Loading...</p>
                <p class="text-muted">Total count of Products in current filter</p>
            </div>
        </div>
    </div>
</div>

<!-- Section 2: Main Section with 4 Charts -->
<div class="section-header">
    <h2>Main Section</h2>
    <p>Key visualizations to analyze pricing trends, volatility, and category performance.</p>
</div>

<div class="row">
    <!-- Chart 1: Average Price Over Time Chart -->
    <div class="col-md-6 mb-4">
        <div class="card h-100">
            <div class="card-header">
                <h5 class="card-title">Average Price Trend Over Time</h5>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="priceTrendChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Chart 2: Price Volatility Chart -->
    <div class="col-md-6 mb-4">
        <div class="card h-100">
            <div class="card-header">
                <h5 class="card-title">Price Volatility by Category</h5>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="volatilityChart"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Chart 3: Category Price Comparison -->
    <div class="col-md-6 mb-4">
        <div class="card h-100">
            <div class="card-header">
                <h5 class="card-title">Category Price Comparison</h5>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="categoryComparisonChart"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Chart 4: Price Growth Rate -->
    <div class="col-md-6 mb-4">
        <div class="card h-100">
            <div class="card-header">
                <h5 class="card-title">Price Growth Rate</h5>
            </div>
            <div class="card-body">
                <div class="chart-container">
                    <canvas id="growthRateChart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Section 3: Deep Dive -->
<div class="section-header">
    <h2>Deep Dive</h2>
    <p>Detailed analysis and insights about pricing strategies and category performance.</p>
</div>

<div class="row">
    <!-- Category Summary Table -->
    <div class="col-12 mb-4">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title">Category Price Summary</h5>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table class="table table-striped table-hover">
                        <thead>
                            <tr>
                                <th>Category</th>
                                <th>Products</th>
                                <th>Min Price</th>
                                <th>Max Price</th>
                                <th>Avg Price</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for item in summary_data %}
                            <tr>
                                <td>{{ item.CategoryName }}</td>
                                <td>{{ item.ProductCount }}</td>
                                <td>${{ item.MinPrice }}</td>
                                <td>${{ item.MaxPrice }}</td>
                                <td>${{ item.AvgPrice }}</td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script type="text/javascript">
    // Initialize data storage
    let chartData = {};
    let volatilityData = [];
    let summaryData = [];

    // Advanced stock chart styling function
    function applyFinanceChartStyling(options) {
        const baseOptions = {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
                duration: 1200,
                easing: 'easeOutQuart'
            },
            layout: {
                padding: {
                    top: 10,
                    right: 25, 
                    bottom: 10,
                    left: 10
                }
            },
            elements: {
                point: {
                    radius: 3,
                    hoverRadius: 6,
                    borderWidth: 2
                },
                line: {
                    tension: 0.35, // Smoother curves
                    borderWidth: 2.5
                },
                bar: {
                    borderWidth: 1,
                    borderRadius: 4
                }
            },
            plugins: {
                legend: {
                    labels: {
                        font: {
                            family: '"Inter", "Segoe UI", Arial',
                            size: 11,
                            weight: 500
                        },
                        padding: 15,
                        usePointStyle: true,
                        pointStyleWidth: 10
                    },
                    position: 'top',
                    align: 'center'
                },
                tooltip: {
                    backgroundColor: 'rgba(17, 24, 39, 0.8)',
                    titleFont: {
                        family: '"Inter", "Segoe UI", Arial',
                        size: 12,
                        weight: 'bold'
                    },
                    bodyFont: {
                        family: '"Inter", "Segoe UI", Arial',
                        size: 11
                    },
                    padding: 10,
                    cornerRadius: 6,
                    displayColors: true,
                    borderColor: 'rgba(255, 255, 255, 0.1)',
                    borderWidth: 1
                }
            },
            scales: {
                x: {
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)',
                        tickLength: 10
                    },
                    ticks: {
                        font: {
                            family: '"Inter", "Segoe UI", Arial',
                            size: 11
                        }
                    },
                    title: {
                        color: '#718096',
                        font: {
                            family: '"Inter", "Segoe UI", Arial',
                            weight: 'bold',
                            size: 12
                        }
                    }
                },
                y: {
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    },
                    ticks: {
                        font: {
                            family: '"Inter", "Segoe UI", Arial',
                            size: 11
                        }
                    },
                    title: {
                        color: '#718096',
                        font: {
                            family: '"Inter", "Segoe UI", Arial',
                            weight: 'bold',
                            size: 12
                        }
                    }
                }
            }
        };
        
        // Deep merge custom options with base options
        return mergeDeep(baseOptions, options || {});
    }
    
    // Helper function for deep merging objects
    function mergeDeep(target, source) {
        const isObject = obj => obj && typeof obj === 'object';
        
        if (!isObject(target) || !isObject(source)) {
            return source;
        }
        
        Object.keys(source).forEach(key => {
            const targetValue = target[key];
            const sourceValue = source[key];
            
            if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
                target[key] = targetValue.concat(sourceValue);
            } else if (isObject(targetValue) && isObject(sourceValue)) {
                target[key] = mergeDeep(Object.assign({}, targetValue), sourceValue);
            } else {
                target[key] = sourceValue;
            }
        });
        
        return target;
    }

// Safely parse data from Flask
(function loadData() {
    try {
        chartData = JSON.parse('{{ chart_data|default({})|tojson|safe }}');
        volatilityData = JSON.parse('{{ volatility_data|default([])|tojson|safe }}');
        summaryData = JSON.parse('{{ summary_data|default([])|tojson|safe }}');
        
        console.log('Chart data loaded:', Object.keys(chartData).length > 0 ? 'Yes' : 'No');
        console.log('Chart data structure:', chartData);
        console.log('Chart data categories:', Object.keys(chartData));
        if (Object.keys(chartData).length > 0) {
            const firstCategory = Object.keys(chartData)[0];
            console.log('Sample data points for ' + firstCategory + ':', chartData[firstCategory].slice(0, 3));
        }
        console.log('Volatility data loaded:', volatilityData.length);
        console.log('Summary data loaded:', summaryData.length);
    } catch (e) {
        console.error('Error parsing data from Flask:', e);
        // Initialize with fallback data if parsing fails
        chartData = {};
        volatilityData = [];
        summaryData = [];
    }
})();

// Generate random colors for each category
function generateRandomColors(count) {
    const colors = [];
    for (let i = 0; i < count; i++) {
        const r = Math.floor(Math.random() * 200);
        const g = Math.floor(Math.random() * 200);
        const b = Math.floor(Math.random() * 200);
        colors.push(`rgba(${r}, ${g}, ${b}, 0.7)`);
    }
    return colors;
}

// Calculate standard deviation for volatility metrics
function calculateStandardDeviation(values) {
    // Calculate the mean
    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    
    // Calculate the sum of squared differences from the mean
    const squaredDiffs = values.map(val => {
        const diff = val - mean;
        return diff * diff;
    });
    
    // Calculate the variance
    const variance = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
    
    // Calculate the standard deviation
    return Math.sqrt(variance);
}

// Price Trend Chart
function createPriceTrendChart(category = 'all', dateRange = '6') {
    const ctx = document.getElementById('priceTrendChart');
    if (!ctx) {
        console.error('Price Trend Chart canvas element not found');
        return;
    }
    
    // Define months at the top of the function scope
    const months = parseInt(dateRange);
    console.log(`Price trend chart using ${months} month(s) filter`);
    
    // Remove any existing no-data message
    const existingMessage = ctx.parentNode.querySelector('.no-data-message');
    if (existingMessage) {
        existingMessage.remove();
    }
    
    // Destroy existing chart instance if it exists
    if (charts.priceTrendChart) {
        charts.priceTrendChart.destroy();
        charts.priceTrendChart = null;
    }
    
    // Check if we have real data from the database
    let filteredChartData = {};
    
    // Only use real data from the SQLite database, never use mock data
    if (chartData && Object.keys(chartData).length > 0) {
        console.log('Using real price trend data from the database');
        
        // Use all categories or filter by selected category
        if (category === 'all') {
            filteredChartData = JSON.parse(JSON.stringify(chartData)); // Deep copy
        } else if (chartData[category]) {
            filteredChartData[category] = chartData[category];
        } else {
            filteredChartData = JSON.parse(JSON.stringify(chartData)); // Fallback to all categories
        }
        
        // Apply date range filter to real data
        const cutoffDate = new Date();
        cutoffDate.setMonth(cutoffDate.getMonth() - months);
        
        for (const cat in filteredChartData) {
            // Filter data points by date
            if (filteredChartData[cat].length > 0) {
                filteredChartData[cat] = filteredChartData[cat].filter(point => {
                    const pointDate = new Date(point.x);
                    return pointDate >= cutoffDate;
                });
            }
        }
        
        console.log(`Filtering for last ${months} months, cutoff date: ${cutoffDate.toDateString()}`);
    } else {
        // No data fallback - show empty chart with a message
        console.log('No price trend data available from database, showing empty chart');
        
        // Remove any existing no-data message
        const existingMessage = ctx.parentNode.querySelector('.no-data-message');
        if (existingMessage) {
            existingMessage.remove();
        }
        
        // Add a no data message to the canvas container
        const noDataMessage = document.createElement('div');
        noDataMessage.className = 'no-data-message';
        noDataMessage.style.position = 'absolute';
        noDataMessage.style.top = '50%';
        noDataMessage.style.left = '50%';
        noDataMessage.style.transform = 'translate(-50%, -50%)';
        noDataMessage.style.textAlign = 'center';
        noDataMessage.style.color = '#6c757d';
        noDataMessage.style.fontWeight = '500';
        noDataMessage.innerHTML = '<i class="fas fa-database me-2"></i>No data available';
        
        // Make sure parent has position relative
        ctx.parentNode.style.position = 'relative';
        ctx.parentNode.appendChild(noDataMessage);
    }
    
    console.log(`Chart data filtered - Category: ${category}, Date Range: ${months} months`);
    
    const datasets = [];
    const categoryColors = generateRandomColors(Object.keys(filteredChartData).length);
    
    let colorIndex = 0;
    for (const [cat, points] of Object.entries(filteredChartData)) {
        datasets.push({
            label: cat,
            data: points,
            fill: false,
            borderColor: categoryColors[colorIndex],
            tension: 0.1
        });
        colorIndex++;
    }

    const chartContext = ctx.getContext('2d');
    charts.priceTrendChart = new Chart(chartContext, {
        type: 'line',
        data: {
            datasets: datasets.map(dataset => ({
                ...dataset,
                pointBackgroundColor: dataset.borderColor,
                pointHoverBackgroundColor: dataset.borderColor,
                borderWidth: 2.5
            }))
        },
        options: applyFinanceChartStyling({
            parsing: {
                xAxisKey: 'x',
                yAxisKey: 'y'
            },
            scales: {
                x: {
                    type: 'time',
                    time: {
                        unit: 'month',
                        tooltipFormat: 'MMM yyyy'
                    },
                    title: {
                        display: true,
                        text: 'Date'
                    }
                },
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Average Price ($)'
                    },
                    ticks: {
                        callback: function(value) {
                            return '$' + value.toFixed(2);
                        }
                    }
                }
            },
            plugins: {
                title: {
                    display: true,
                    text: `Price Trend Over ${months} Month${months > 1 ? 's' : ''}${category !== 'all' ? ' for ' + category : ''}`,
                    font: {
                        size: 16,
                        weight: 'bold'
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return context.dataset.label + ': $' + parseFloat(context.parsed.y).toFixed(2);
                        }
                    }
                }
            }
        })
    });
    
    return charts.priceTrendChart;
}

// Price Volatility Chart
function createVolatilityChart(category = 'all') {
    const ctx = document.getElementById('volatilityChart');
    if (!ctx) {
        console.error('Volatility Chart canvas element not found');
        return;
    }
    
    // Remove any existing no-data message
    const existingMessage = ctx.parentNode.querySelector('.no-data-message');
    if (existingMessage) {
        existingMessage.remove();
    }
    
    // Destroy existing chart instance if it exists
    if (charts.volatilityChart) {
        charts.volatilityChart.destroy();
        charts.volatilityChart = null;
    }
    
    let filteredData = [];
    
    // Only use real data from the database, never mock data
    if (volatilityData && volatilityData.length > 0) {
        filteredData = JSON.parse(JSON.stringify(volatilityData)); // Create deep copy
        console.log('Using real volatility data for chart');
        
        // Apply category filter to real data
        if (category !== 'all') {
            filteredData = filteredData.filter(item => item.CategoryName === category);
        }
        
        // If we have data after filtering, create the chart
        if (filteredData.length > 0) {
            const labels = filteredData.map(item => item.CategoryName);
            const priceRanges = filteredData.map(item => item.PriceRange);
            
            const chartContext = ctx.getContext('2d');
            const colors = generateRandomColors(labels.length);
            
            charts.volatilityChart = new Chart(chartContext, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Price Range ($)',
                        data: priceRanges,
                        backgroundColor: colors,
                        borderColor: colors.map(color => color.replace('0.7', '1')),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Price Range ($)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Category'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: category !== 'all' ? 
                                `Price Range by Category - ${category}` : 
                                'Price Range by Category'
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return 'Price Range: $' + context.parsed.y;
                                }
                            }
                        }
                    }
                }
            });
            
            console.log(`Volatility Chart created with ${filteredData.length} data points`);
            return charts.volatilityChart;
        }
    }
    
    // If we get here, we don't have data to show
    console.log('No volatility data available, showing empty chart');
    
    // Add a no data message
    const noDataMessage = document.createElement('div');
    noDataMessage.className = 'no-data-message';
    noDataMessage.innerHTML = '<i class="fas fa-chart-line"></i>No data available';
    noDataMessage.style.top = '50%';
    noDataMessage.style.left = '50%';
    noDataMessage.style.transform = 'translate(-50%, -50%)';
    noDataMessage.style.textAlign = 'center';
    noDataMessage.style.color = '#6c757d';
    noDataMessage.style.fontWeight = '500';
    
    // Make sure parent has position relative
    ctx.parentNode.style.position = 'relative';
    ctx.parentNode.appendChild(noDataMessage);
    
    // Create empty chart
    charts.volatilityChart = new Chart(ctx.getContext('2d'), {
        type: 'bar',
        data: {
            labels: [],
            datasets: []
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: 'Price Range by Category'
                }
            }
        }
    });
    
    return charts.volatilityChart;
}

// Category Comparison Chart
function createCategoryComparisonChart(category = 'all') {
    const ctx = document.getElementById('categoryComparisonChart');
    if (!ctx) {
        console.error('Category Comparison Chart canvas element not found');
        return;
    }
    
    // Remove any existing no-data message
    const existingMessage = ctx.parentNode.querySelector('.no-data-message');
    if (existingMessage) {
        existingMessage.remove();
    }
    
    // Destroy existing chart instance if it exists
    if (charts.categoryComparisonChart) {
        charts.categoryComparisonChart.destroy();
        charts.categoryComparisonChart = null;
    }
    
    const chartContext = ctx.getContext('2d');
    
    // Default attributes for each category to measure in the radar chart
    const radarAttributes = ['Price', 'Variety', 'Growth', 'Volatility', 'Demand'];
    
    // Attempt to derive some real metrics from our database data
    let realCategoryMetrics = {};
    
    // Use summary data and volatility data if available
    if (summaryData && summaryData.length > 0 && volatilityData && volatilityData.length > 0) {
        console.log('Generating category comparison metrics from real data');
        
        // Generate metrics for all categories in our summary data
        summaryData.forEach(catSummary => {
            const catName = catSummary.CategoryName;
            
            // Find volatility data for this category
            const volatilityInfo = volatilityData.find(v => v.CategoryName === catName);
            
            // Skip if we don't have complete data
            if (!volatilityInfo) return;
            
            // Calculate normalized scores (0-100) for each metric
            // Price score: lower is better (inverse scale)
            const maxPossiblePrice = Math.max(...summaryData.map(s => parseFloat(s.AvgPrice)));
            const priceScore = maxPossiblePrice > 0 ? 
                100 - (parseFloat(catSummary.AvgPrice) / maxPossiblePrice * 100) : 50;
            
            // Variety score: higher product count is better
            const maxProductCount = Math.max(...summaryData.map(s => parseInt(s.ProductCount)));
            const varietyScore = maxProductCount > 0 ? 
                (parseInt(catSummary.ProductCount) / maxProductCount * 100) : 50;
            
            // Growth rate: random for now as we don't have this data
            const growthScore = 50 + Math.random() * 30;
            
            // Volatility: lower is better (inverse scale)
            const maxVolatility = Math.max(...volatilityData.map(v => parseFloat(v.PriceRange)));
            const volatilityScore = maxVolatility > 0 ? 
                100 - (parseFloat(volatilityInfo.PriceRange) / maxVolatility * 100) : 50;
            
            // Demand: random for now
            const demandScore = 40 + Math.random() * 60;
            
            // Store the metrics
            realCategoryMetrics[catName] = [priceScore, varietyScore, growthScore, volatilityScore, demandScore];
        });
    }
    
    // Prepare datasets based on filter
    const datasets = [];
    const colors = {
        'Electronics': {bg: 'rgba(54, 162, 235, 0.2)', border: 'rgb(54, 162, 235)'},
        'Clothing': {bg: 'rgba(255, 99, 132, 0.2)', border: 'rgb(255, 99, 132)'},
        'Home Goods': {bg: 'rgba(75, 192, 192, 0.2)', border: 'rgb(75, 192, 192)'},
        'Sports': {bg: 'rgba(255, 159, 64, 0.2)', border: 'rgb(255, 159, 64)'},
        'Books': {bg: 'rgba(153, 102, 255, 0.2)', border: 'rgb(153, 102, 255)'}
    };
    
    // Only use real data, never sample/mock data
    console.log(`Using real data for Category Comparison - ${Object.keys(realCategoryMetrics).length} categories available`);
    
    // Only create chart if we have real data available
    if (Object.keys(realCategoryMetrics).length > 0) {
        if (category === 'all') {
            // Show selected categories (up to 3 for readability)
            const selectedCategories = Object.keys(realCategoryMetrics).slice(0, 3);
            
            selectedCategories.forEach(cat => {
                datasets.push({
                    label: cat,
                    data: realCategoryMetrics[cat],
                    backgroundColor: colors[cat]?.bg || `rgba(${Math.floor(Math.random()*255)}, ${Math.floor(Math.random()*255)}, ${Math.floor(Math.random()*255)}, 0.2)`,
                    borderColor: colors[cat]?.border || `rgb(${Math.floor(Math.random()*255)}, ${Math.floor(Math.random()*255)}, ${Math.floor(Math.random()*255)})`,
                    pointBackgroundColor: colors[cat]?.border || `rgb(${Math.floor(Math.random()*255)}, ${Math.floor(Math.random()*255)}, ${Math.floor(Math.random()*255)})`,
                    pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: colors[cat]?.border || `rgb(${Math.floor(Math.random()*255)}, ${Math.floor(Math.random()*255)}, ${Math.floor(Math.random()*255)})` 
                });
            });
        } else if (realCategoryMetrics[category]) {
            // Show just the selected category 
            datasets.push({
                label: category,
                data: realCategoryMetrics[category],
                backgroundColor: colors[category]?.bg || 'rgba(54, 162, 235, 0.2)',
                borderColor: colors[category]?.border || 'rgb(54, 162, 235)',
                pointBackgroundColor: colors[category]?.border || 'rgb(54, 162, 235)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: colors[category]?.border || 'rgb(54, 162, 235)'
            });
            
            // Add average category for comparison
            const avgData = [];
            for (let i = 0; i < radarAttributes.length; i++) {
                let sum = 0, count = 0;
                Object.values(realCategoryMetrics).forEach(values => {
                    if (values[i] !== undefined) {
                        sum += values[i];
                        count++;
                    }
                });
                avgData.push(count > 0 ? sum / count : 50);
            }
            
            datasets.push({
                label: 'Average Category',
                data: avgData,
                backgroundColor: 'rgba(128, 128, 128, 0.2)',
                borderColor: 'rgb(128, 128, 128)',
                pointBackgroundColor: 'rgb(128, 128, 128)',
                pointBorderColor: '#fff',
                pointHoverBackgroundColor: '#fff',
                pointHoverBorderColor: 'rgb(128, 128, 128)'
            });
        } else {
            // Selected category not found in data, show no data message
            console.log('Selected category not found in real data');
            return showNoDataMessage();
        }
    } else {
        // No real data available at all
        console.log('No real category comparison data available');
        return showNoDataMessage();
    }
    
    console.log(`Category Comparison Chart filtered - Category: ${category}, Datasets: ${datasets.length}`);
    
    // Create chart if we have datasets
    if (datasets.length > 0) {
        charts.categoryComparisonChart = new Chart(chartContext, {
            type: 'radar',
            data: {
                labels: radarAttributes,
                datasets: datasets.map(dataset => ({
                    ...dataset,
                    borderWidth: 1,
                    borderRadius: 4,
                    hoverBackgroundColor: dataset.backgroundColor.replace('0.7', '0.9')
                }))
            },
            options: applyFinanceChartStyling({
                scales: {
                    r: {
                        angleLines: {
                            color: 'rgba(0, 0, 0, 0.1)',
                        },
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        },
                        pointLabels: {
                            font: {
                                family: '"Inter", "Segoe UI", Arial',
                                size: 11,
                                weight: 500
                            },
                            color: '#2D3748'
                        },
                        ticks: {
                            backdropColor: 'transparent',
                            font: {
                                size: 10
                            }
                        }
                    }
                },
                elements: {
                    line: {
                        borderWidth: 2
                    },
                    point: {
                        radius: 3
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Category Performance Comparison',
                        font: {
                            size: 16,
                            weight: 'bold'
                        }
                    }
                }
            })
        });
        
        return charts.categoryComparisonChart;
    }
    
    // Function to show no data message
    function showNoDataMessage() {
        console.log('No comparison data available, showing empty chart');
        
        // Add a no data message
        const noDataMessage = document.createElement('div');
        noDataMessage.className = 'no-data-message';
        noDataMessage.style.position = 'absolute';
        noDataMessage.style.top = '50%';
        noDataMessage.style.left = '50%';
        noDataMessage.style.transform = 'translate(-50%, -50%)';
        noDataMessage.style.textAlign = 'center';
        noDataMessage.style.color = '#6c757d';
        noDataMessage.style.fontWeight = '500';
        noDataMessage.innerHTML = '<i class="fas fa-database me-2"></i>No data available';
        
        // Make sure parent has position relative
        ctx.parentNode.style.position = 'relative';
        ctx.parentNode.appendChild(noDataMessage);
        
        // Create empty chart
        charts.categoryComparisonChart = new Chart(chartContext, {
            type: 'radar',
            data: {
                labels: radarAttributes,
                datasets: []
            },
            options: applyFinanceChartStyling({
                scales: {
                    r: {
                        angleLines: {
                            color: 'rgba(0, 0, 0, 0.1)',
                        },
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        },
                        pointLabels: {
                            font: {
                                family: '"Inter", "Segoe UI", Arial',
                                size: 11,
                                weight: 500
                            },
                            color: '#2D3748'
                        },
                        ticks: {
                            backdropColor: 'transparent',
                            font: {
                                size: 10
                            }
                        }
                    }
                },
                elements: {
                    line: {
                        borderWidth: 2
                    },
                    point: {
                        radius: 3
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Category Performance Comparison',
                        font: {
                            size: 16,
                            weight: 'bold'
                        }
                    }
                }
            })
        });
        
        return charts.categoryComparisonChart;
    }
}

// Growth Rate Chart
function createGrowthRateChart(category = 'all', dateRange = '6') {
    const ctx = document.getElementById('growthRateChart');
    if (!ctx) {
        console.error('Growth Rate Chart canvas element not found');
        return;
    }
    
    const chartContext = ctx.getContext('2d');
    
    let datasets = [];
    const months = parseInt(dateRange);
    let realLabels = [];
    
    // Function to show no data message
    function showNoDataMessage() {
        console.log('No growth data available, showing empty chart');
        
        // Add a no data message
        const noDataMessage = document.createElement('div');
        noDataMessage.className = 'no-data-message';
        noDataMessage.style.position = 'absolute';
        noDataMessage.style.top = '50%';
        noDataMessage.style.left = '50%';
        noDataMessage.style.transform = 'translate(-50%, -50%)';
        noDataMessage.style.textAlign = 'center';
        noDataMessage.style.color = '#6c757d';
        noDataMessage.style.fontWeight = '500';
        noDataMessage.innerHTML = '<i class="fas fa-database me-2"></i>No data available';
        
        // Make sure parent has position relative
        ctx.parentNode.style.position = 'relative';
        ctx.parentNode.appendChild(noDataMessage);
        
        // Create empty chart
        charts.growthRateChart = new Chart(chartContext, {
            type: 'line',
            data: {
                labels: [],
                datasets: []
            },
            options: applyFinanceChartStyling({
                elements: {
                    line: {
                        tension: 0.4, // More curved lines for growth chart
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Price Growth Rate',
                        font: {
                            size: 16,
                            weight: 'bold'
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += parseFloat(context.parsed.y).toFixed(2) + '%';
                                }
                                return label;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Growth Rate (%)'
                        },
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Month'
                        }
                    }
                }
            })
        });
        
        return charts.growthRateChart;
    }
    
    // Remove any existing no-data message
    const existingMessage = ctx.parentNode.querySelector('.no-data-message');
    if (existingMessage) {
        existingMessage.remove();
    }
    
    // Destroy existing chart instance if it exists
    if (charts.growthRateChart) {
        charts.growthRateChart.destroy();
        charts.growthRateChart = null;
    }
    
    // Only use real data from the database, never mock data
    if (chartData && Object.keys(chartData).length > 0) {
        console.log('Using real price data to calculate growth trends');
        console.log('Growth Rate Chart - Chart data structure:', chartData);
        
        // Data is structured with categories as keys, each containing array of {x: date, y: price}
        // Get categories we need to process based on filter
        let categoriesToProcess = [];
        
        if (category === 'all') {
            categoriesToProcess = Object.keys(chartData);
        } else if (chartData[category]) {
            categoriesToProcess = [category];
        }
        
        console.log('Growth Rate Chart - Categories to process:', categoriesToProcess);
        
        // Process each selected category
        categoriesToProcess.forEach(categoryName => {
            if (!chartData[categoryName] || !chartData[categoryName].length) return;
            
            console.log(`Processing category ${categoryName} with ${chartData[categoryName].length} data points`);
            
            // Sort data points chronologically
            const dataPoints = [...chartData[categoryName]].sort((a, b) => new Date(a.x) - new Date(b.x));
            
            // Filter by date range
            const currentDate = new Date();
            const cutoffDate = new Date(); 
            cutoffDate.setMonth(cutoffDate.getMonth() - months);
            
            const filteredPoints = dataPoints.filter(point => {
                const pointDate = new Date(point.x);
                return pointDate >= cutoffDate;
            });
            
            console.log(`After date filtering: ${filteredPoints.length} points remain`);
            
            // Need at least 2 points for growth calculation
            if (filteredPoints.length > 1) {
                // Use the dates for labels if this is the first dataset
                if (realLabels.length === 0) {
                    realLabels = filteredPoints.map(point => {
                        const d = new Date(point.x);
                        return d.toLocaleDateString(undefined, { month: 'short', year: 'numeric' });
                    });
                }
                
                // Get price values
                const prices = filteredPoints.map(point => parseFloat(point.y));
                
                // Calculate growth using first price as baseline
                const firstPrice = prices[0];
                if (firstPrice && firstPrice > 0) {
                    const growthData = prices.map(price => {
                        return ((price - firstPrice) / firstPrice) * 100;
                    });
                    
                    // Generate a color for this dataset
                    const color = generateRandomColors(1)[0];
                    
                    // Add dataset
                    datasets.push({
                        label: `${categoryName} Growth`,
                        data: growthData,
                        borderColor: color,
                        backgroundColor: color.replace('1)', '0.1)'),
                        borderWidth: 2,
                        fill: false
                    });
                    
                    console.log(`Added dataset for ${categoryName} with ${growthData.length} points`);
                }
            }
        });
        
        // Create the chart if we have datasets
        if (datasets.length > 0) {
            console.log(`Growth Rate: Creating chart with ${datasets.length} datasets, months: ${months}`);
            charts.growthRateChart = new Chart(chartContext, {
                type: 'line',
                data: {
                    labels: realLabels,
                    datasets: datasets.map(dataset => ({
                        ...dataset,
                        pointBackgroundColor: dataset.borderColor,
                        pointHoverBackgroundColor: dataset.borderColor,
                        borderWidth: 2.5
                    }))
                },
                options: applyFinanceChartStyling({
                    elements: {
                        line: {
                            tension: 0.4, // More curved lines for growth chart
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Price Growth Over ${months} Month${months > 1 ? 's' : ''}${category !== 'all' ? ' for ' + category : ''}`,
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += parseFloat(context.parsed.y).toFixed(2) + '%';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Growth Rate (%)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Month'
                            }
                        }
                    }
                })
            });
        } else {
            // No data for the selected category
            showNoDataMessage();
        }
    } else {
        // No data available at all
        showNoDataMessage();
    }
    
    updateContextCards(category);
    
    return charts.growthRateChart;
}

// Filter functionality
function applyFilters() {
    const categoryValue = document.getElementById('categoryFilter').value;
    const dateRangeValue = document.getElementById('dateRangeFilter').value;
    
    console.log('Applying filters - Category:', categoryValue, 'Date Range:', dateRangeValue);
    
    // In an ideal implementation, we would make an AJAX call to get fresh data
    // For example: fetch(`/api/strategic/data?category=${categoryValue}&dateRange=${dateRangeValue}`)
    // But for now, we'll filter the data we already have client-side
    
    // Update context section with filtered data based on the database values
    updateContextCards(categoryValue);
    
    // Destroy and recreate charts with filtered data
    destroyCharts();
    createPriceTrendChart(categoryValue, dateRangeValue);
    createVolatilityChart(categoryValue);
    createCategoryComparisonChart(categoryValue);
    createGrowthRateChart(categoryValue, dateRangeValue);
    
    // Update category summary table if possible
    updateCategorySummaryTable(categoryValue);
    
    // Show success message
    // Remove any previous alert
    const previousAlert = document.querySelector('.alert.alert-success');
    if (previousAlert) {
        previousAlert.remove();
    }
    
    const alertBox = document.createElement('div');
    alertBox.className = 'alert alert-success alert-dismissible fade show mt-3';
    alertBox.setAttribute('role', 'alert');
    alertBox.innerHTML = `
        Filters applied: Category - <strong>${categoryValue === 'all' ? 'All Categories' : categoryValue}</strong>, 
        Date Range - <strong>Last ${dateRangeValue} months</strong>
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    `;
    
    // Find filter card and insert alert after it
    const filterCard = document.querySelector('.card.mb-4');
    filterCard.parentNode.insertBefore(alertBox, filterCard.nextSibling);
}

// Update the category summary table based on filter
function updateCategorySummaryTable(category) {
    // Find the summary table body
    const tableBody = document.querySelector('.table.table-striped.table-hover tbody');
    if (!tableBody) return;
    
    // If we have real summary data and it's not empty
    if (summaryData && summaryData.length > 0) {
        // Filter the data if category is not 'all'
        let filteredSummary = summaryData;
        if (category !== 'all') {
            filteredSummary = summaryData.filter(item => item.CategoryName === category);
            if (filteredSummary.length === 0) {
                filteredSummary = summaryData; // Fallback to all data if no match
            }
        }
        
        // Clear existing table rows
        tableBody.innerHTML = '';
        
        // Add filtered rows
        filteredSummary.forEach(item => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${item.CategoryName}</td>
                <td>${item.ProductCount}</td>
                <td>$${parseFloat(item.MinPrice).toFixed(2)}</td>
                <td>$${parseFloat(item.MaxPrice).toFixed(2)}</td>
                <td>$${parseFloat(item.AvgPrice).toFixed(2)}</td>
            `;
            tableBody.appendChild(row);
        });
        
        console.log(`Category summary table updated with ${filteredSummary.length} rows`); 
    }
}

// Update context cards with filtered data
function updateContextCards(category) {
    console.log('updateContextCards called with category:', category);
    
    // Default values in case we don't have data
    let minPrice = 10, maxPrice = 500, avgPrice = 250;
    let totalProducts = 0;
    let mostStableCategory = 'N/A';
    let mostVolatileCategory = 'N/A';
    let categoryVolatility = {};
    
    // Debug data availability
    console.log('summaryData available:', summaryData ? true : false);
    console.log('chartData available:', chartData ? true : false);
    if (chartData) {
        console.log('chartData categories:', Object.keys(chartData));
        for (const cat in chartData) {
            console.log(`${cat} data points:`, chartData[cat] ? chartData[cat].length : 0);
        }
    }
    
    // Try to get real data from summary data if available
    if (summaryData && summaryData.length > 0) {
        // Calculate total product count based on the current filter
        if (category !== 'all' && category) {
            // Find the specific category data
            const categoryData = summaryData.find(item => item.CategoryName === category);
            if (categoryData) {
                minPrice = parseFloat(categoryData.MinPrice).toFixed(2);
                maxPrice = parseFloat(categoryData.MaxPrice).toFixed(2);
                avgPrice = parseFloat(categoryData.AvgPrice).toFixed(2);
                totalProducts = parseInt(categoryData.ProductCount);
                
                console.log(`Using real data for ${category}: Min: $${minPrice}, Max: $${maxPrice}, Avg: $${avgPrice}, Products: ${totalProducts}`);
                
                // For a single category, we still compute volatility for all categories for comparison
                if (chartData) {
                    Object.keys(chartData).forEach(cat => {
                        if (chartData[cat] && chartData[cat].length >= 2) {
                            // Calculate price volatility as standard deviation
                            const prices = chartData[cat].map(point => parseFloat(point.y));
                            categoryVolatility[cat] = calculateStandardDeviation(prices);
                        }
                    });
                }
            } else {
                console.log(`No real data found for ${category}, using defaults`);
            }
        } else {
            // Calculate overall min, max and average across all categories
            minPrice = Math.min(...summaryData.map(item => parseFloat(item.MinPrice))).toFixed(2);
            maxPrice = Math.max(...summaryData.map(item => parseFloat(item.MaxPrice))).toFixed(2);
            
            // Calculate weighted average based on product count
            totalProducts = summaryData.reduce((sum, item) => sum + parseInt(item.ProductCount), 0);
            const weightedSum = summaryData.reduce((sum, item) => {
                return sum + (parseFloat(item.AvgPrice) * parseInt(item.ProductCount));
            }, 0);
            avgPrice = totalProducts > 0 ? (weightedSum / totalProducts).toFixed(2) : 250;
            
            console.log(`Using overall real data for all categories. Total Products: ${totalProducts}`);
            
            // Calculate volatility for all categories
            if (chartData) {
                Object.keys(chartData).forEach(cat => {
                    if (chartData[cat] && chartData[cat].length >= 2) {
                        // Calculate price volatility as standard deviation
                        const prices = chartData[cat].map(point => parseFloat(point.y));
                        categoryVolatility[cat] = calculateStandardDeviation(prices);
                    }
                });
            }
        }
        
        // Find most stable and most volatile categories (if we have volatility data)
        if (Object.keys(categoryVolatility).length > 0) {
            // Sort categories by volatility
            const sortedCategories = Object.keys(categoryVolatility).sort((a, b) => categoryVolatility[a] - categoryVolatility[b]);
            mostStableCategory = sortedCategories[0];
            mostVolatileCategory = sortedCategories[sortedCategories.length - 1];
            
            console.log(`Most stable category: ${mostStableCategory} (${categoryVolatility[mostStableCategory].toFixed(2)})`);
            console.log(`Most volatile category: ${mostVolatileCategory} (${categoryVolatility[mostVolatileCategory].toFixed(2)})`);
        }
    } else {
        // Fallback to sample data if no real data available
        console.log('No real summary data available, using sample data for context cards');
        
        if (category === 'Electronics') {
            minPrice = 100;
            maxPrice = 1200;
            avgPrice = 450;
            totalProducts = 125;
            mostStableCategory = 'Monitors';
            mostVolatileCategory = 'Smartphones';
        } else if (category === 'Clothing') {
            minPrice = 20;
            maxPrice = 150;
            avgPrice = 65;
            totalProducts = 240;
            mostStableCategory = 'Socks';
            mostVolatileCategory = 'Designer Shoes';
        } else if (category === 'Home Goods') {
            minPrice = 50;
            maxPrice = 350;
            avgPrice = 180;
            totalProducts = 180;
            mostStableCategory = 'Kitchen Utensils';
            mostVolatileCategory = 'Furniture';
        } else {
            totalProducts = 545;
            mostStableCategory = 'Groceries';
            mostVolatileCategory = 'Electronics';
        }
    }
    
    // Find the price range card and update its content
    const priceRangeTitle = Array.from(document.querySelectorAll('.card-title')).find(el => el.textContent.includes('Price Range'));
    if (priceRangeTitle) {
        const priceRangeDisplay = priceRangeTitle.nextElementSibling;
        if (priceRangeDisplay && priceRangeDisplay.classList.contains('display-4')) {
            priceRangeDisplay.textContent = `$${minPrice} - $${maxPrice}`;
        }
    }
    
    // Find the average price card and update its content
    const avgPriceTitle = Array.from(document.querySelectorAll('.card-title')).find(el => el.textContent.includes('Average Price'));
    if (avgPriceTitle) {
        const avgPriceDisplay = avgPriceTitle.nextElementSibling;
        if (avgPriceDisplay && avgPriceDisplay.classList.contains('display-4')) {
            avgPriceDisplay.textContent = `$${avgPrice}`;
        }
    }
    
    // Ensure all values have defaults if calculation failed
    if (!mostStableCategory || mostStableCategory === 'N/A' || mostStableCategory === 'undefined') {
        // If we have chartData but couldn't calculate volatility, just use the first category
        if (chartData && Object.keys(chartData).length > 0) {
            mostStableCategory = Object.keys(chartData)[0];
            console.log('Using fallback for most stable category:', mostStableCategory);
        } else {
            mostStableCategory = 'Not available';
        }
    }
    
    if (!mostVolatileCategory || mostVolatileCategory === 'N/A' || mostVolatileCategory === 'undefined') {
        // If we have chartData but couldn't calculate volatility, use the last category
        if (chartData && Object.keys(chartData).length > 0) {
            mostVolatileCategory = Object.keys(chartData)[Object.keys(chartData).length - 1];
            console.log('Using fallback for most volatile category:', mostVolatileCategory);
        } else {
            mostVolatileCategory = 'Not available';
        }
    }

    // Update the new context cards
    document.getElementById('most-stable-category').textContent = mostStableCategory;
    document.getElementById('most-volatile-category').textContent = mostVolatileCategory;
    document.getElementById('total-products').textContent = totalProducts > 0 ? totalProducts.toLocaleString() : 'Not available';
    
    console.log('Context cards updated with: Stable =', mostStableCategory, ', Volatile =', mostVolatileCategory, ', Total =', totalProducts);
}

// Store chart instances to destroy them before recreating
let charts = {
    priceTrendChart: null,
    volatilityChart: null,
    categoryComparisonChart: null,
    growthRateChart: null
};

// Destroy all charts before recreating
function destroyCharts() {
    Object.values(charts).forEach(chart => {
        if (chart) chart.destroy();
    });
}

// Initialize charts and set up event listeners
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM Content Loaded - Initializing dashboard...');
    
    // Initialize charts
    createPriceTrendChart();
    createVolatilityChart();
    createCategoryComparisonChart();
    createGrowthRateChart();
    
    // Initialize context cards with default 'all' category
    updateContextCards('all');
    
    // Update category summary table
    updateCategorySummaryTable('all');
    
    // Set up filter event listener
    document.getElementById('applyFilters').addEventListener('click', applyFilters);
    
    console.log('Dashboard initialized with all components');
});
</script>
{% endblock %}
